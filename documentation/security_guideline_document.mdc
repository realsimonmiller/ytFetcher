---
description: Apply these rules when making changes to the project
globs:
alwaysApply: true
---

Update this rule if user requested changes to the project requirement, etc.
Here’s an implementation plan and a secure, resilient Python script that meets your requirements. We’ll use:

• Python 3.8+ with a virtual environment (venv)
• yt-dlp (default) or youtube-dl, configurable via an INI file
• configparser for configuration
• subprocess calls without shell=True to prevent injection
• Safe file and path handling via pathlib
• Robust logging (downloaded_videos.log, errors.log)
• notify-send via subprocess for desktop notifications
• Retry logic with exponential back-off

---

## 1. Project Structure

  youtube_fetcher/
  ├── config.ini            # User-editable settings
  ├── downloaded_videos.log # IDs of successfully downloaded videos
  ├── errors.log            # Errors and stack traces
  ├── fetcher.py            # Main script
  └── venv/                 # Python virtual environment

---

## 2. config.ini (secure defaults)

```ini
[general]
# Choose backend: yt-dlp or youtube-dl
downloader = yt-dlp
# Base output directory
output_dir = downloads/youtubeFetcher
# Max retries per video
max_retries = 3
# Date filter (ISO YYYY-MM-DD) or leave blank
start_date =
end_date =

[notifications]
enabled = true

[logging]
downloaded_log = downloaded_videos.log
error_log = errors.log
``` 

Ensure `config.ini` is owned by the calling user and has permissions 600.

---

## 3. fetcher.py

```python
#!/usr/bin/env python3
"""
youtube_fetcher: download all public videos from a YouTube channel,
skip duplicates, organize into channel/title folders,
with retries, logging, and desktop notifications.
"""
import argparse
import configparser
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path

# ----- Constants & Setup -----
CONFIG_PATH = Path(__file__).parent / 'config.ini'

# Validate config exists
if not CONFIG_PATH.is_file():
    sys.exit(f"Configuration file not found: {CONFIG_PATH}")

# Read config securely
config = configparser.ConfigParser()
config.read(CONFIG_PATH)

general = config['general']
NOTIF = config.getboolean('notifications', 'enabled', fallback=True)
LOGGING = config['logging']

DOWNLOADER = general.get('downloader', 'yt-dlp')
if DOWNLOADER not in ('yt-dlp', 'youtube-dl'):
    sys.exit("Downloader must be 'yt-dlp' or 'youtube-dl'")

OUTPUT_DIR = Path(general.get('output_dir', 'downloads/youtubeFetcher')).expanduser()
MAX_RETRIES = general.getint('max_retries', 3)
START_DATE = general.get('start_date', fallback=None)
END_DATE = general.get('end_date', fallback=None)

DL_LOG_PATH = Path(LOGGING.get('downloaded_log', 'downloaded_videos.log')).resolve()
ERR_LOG_PATH = Path(LOGGING.get('error_log', 'errors.log')).resolve()

# Ensure logs exist and have secure perms
for p in (DL_LOG_PATH, ERR_LOG_PATH):
    p.touch(mode=0o600, exist_ok=True)

# Utility: log errors
def log_error(msg: str):
    timestamp = datetime.utcnow().isoformat()
    with ERR_LOG_PATH.open('a', encoding='utf-8') as f:
        f.write(f"[{timestamp}] {msg}\n")

# Utility: desktop notification
def notify(summary: str, body: str = ''):
    if NOTIF:
        try:
            subprocess.run(
                ['notify-send', summary, body],
                check=True,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
        except Exception as e:
            log_error(f"Notification failed: {e}")

# Validate channel URL
def validate_channel_url(url: str) -> str:
    if not url.startswith(('https://www.youtube.com/', 'https://youtube.com/')):
        sys.exit("Invalid YouTube channel URL.")
    return url.rstrip('/')

# Fetch metadata via yt-dlp/youtube-dl JSON output
import json
def fetch_video_list(channel_url: str) -> list:
    cmd = [DOWNLOADER, '--dump-single-json', channel_url]
    try:
        result = subprocess.run(
            cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        data = json.loads(result.stdout)
    except Exception as e:
        log_error(f"Failed to fetch metadata: {e}")
        sys.exit("Cannot proceed without metadata.")

    # Extract entries
    entries = data.get('entries', [])
    videos = []
    for e in entries:
        vid = e.get('id')
        title = e.get('title')
        date = e.get('upload_date')  # YYYYMMDD
        if not (vid and title and date):
            continue
        # Apply date filter
        if START_DATE and date < START_DATE.replace('-', ''):
            continue
        if END_DATE and date > END_DATE.replace('-', ''):
            continue
        videos.append({'id': vid, 'title': title, 'date': date})
    # Newest first
    videos.sort(key=lambda x: x['date'], reverse=True)
    return videos

# Load downloaded IDs
def load_downloaded_ids() -> set:
    return set(line.strip() for line in DL_LOG_PATH.read_text(encoding='utf-8').splitlines() if line.strip())

# Append ID on success
def mark_downloaded(video_id: str):
    with DL_LOG_PATH.open('a', encoding='utf-8') as f:
        f.write(video_id + '\n')

# Download a single video with retries
import shlex
def download_video(channel_name: str, video: dict) -> bool:
    vid, title = video['id'], video['title']
    safe_title = ''.join(c for c in title if c.isalnum() or c in ' _-').strip()
    target_dir = OUTPUT_DIR / channel_name / safe_title
    target_dir.mkdir(parents=True, exist_ok=True)

    for attempt in range(1, MAX_RETRIES + 1):
        try:
            cmd = [
                DOWNLOADER,
                f"https://youtu.be/{vid}",
                '-f', 'best',
                '-o', str(target_dir / '%(title)s.%(ext)s')
            ]
            subprocess.run(cmd, check=True)
            return True
        except subprocess.CalledProcessError as e:
            log_error(f"Attempt {attempt} failed for {vid}: {e}")
            time.sleep(2 ** attempt)
    return False

# Main flow
def main():
    parser = argparse.ArgumentParser(description="Download all public videos from a YouTube channel.")
    parser.add_argument('channel_url', help="YouTube channel URL")
    args = parser.parse_args()

    channel_url = validate_channel_url(args.channel_url)
    channel_name = channel_url.rstrip('/').split('/')[-1]

    videos = fetch_video_list(channel_url)
    downloaded_ids = load_downloaded_ids()

    downloaded_count = 0
    skipped_count = 0

    for video in videos:
        if video['id'] in downloaded_ids:
            skipped_count += 1
            continue
        success = download_video(channel_name, video)
        if success:
            mark_downloaded(video['id'])
            downloaded_count += 1
        else:
            log_error(f"Failed to download after retries: {video['id']}")

    notify(
        summary="YouTube Fetcher Complete",
        body=f"Downloaded: {downloaded_count}, Skipped: {skipped_count}"
    )

if __name__ == '__main__':
    main()
```

### Security Considerations Implemented

• Input Validation: We validate the channel URL format.  
• No shell=True: All subprocess calls use argument lists.  
• Path Sanitization: We build paths via pathlib and sanitize titles.  
• Secure Logging: Logs are created with mode 600.  
• Secrets: No hard-coded secrets or credentials.  
• Fail Securely: On fatal errors, we exit without leaving partial state.  
• Least Privilege: Runs as the invoking user; directories under user home.  

---

## 4. Setup & Usage

1. Clone or copy the directory.  
2. `cd youtube_fetcher`  
3. `python3 -m venv venv && source venv/bin/activate`  
4. `pip install yt-dlp`  # or `youtube-dl` if you switch in config  
5. Edit `config.ini` as needed (permissions 600).  
6. Run:  
   `./fetcher.py https://www.youtube.com/c/YourChannelName`  

Your videos will land under `downloads/youtubeFetcher/{channelName}/{videoTitle}`.  
Logs and errors appear in the working directory.  

That completes a secure, robust implementation aligned with your requirements. Let me know if you need enhancements or CI/CD integration!  